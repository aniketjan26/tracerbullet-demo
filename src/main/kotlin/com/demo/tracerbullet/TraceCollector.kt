package com.demo.tracerbullet

import org.http4k.core.Method
import org.http4k.core.Status
import java.time.Duration
import java.time.Instant
import java.util.concurrent.ConcurrentHashMap

/**
 * Represents a completed span with all its metadata
 */
data class SpanData(
    val traceId: String,
    val spanId: String,
    val parentSpanId: String?,
    val serviceName: String,
    val method: Method,
    val uri: String,
    val status: Status,
    val startTime: Instant,
    val duration: Duration,
    val order: Int // To maintain order of spans
)

/**
 * Represents a complete trace with all its spans
 */
data class TraceData(
    val traceId: String,
    val spans: MutableList<SpanData> = mutableListOf(),
    var completed: Boolean = false
) {
    fun addSpan(span: SpanData) {
        synchronized(spans) {
            spans.add(span)
        }
    }

    fun getRootSpan(): SpanData? = spans.firstOrNull { it.parentSpanId == null }

    fun getSpansByParent(parentId: String): List<SpanData> =
        spans.filter { it.parentSpanId == parentId }

    fun getAllSpansOrdered(): List<SpanData> = spans.sortedBy { it.order }
}

/**
 * Collects trace data for diagram generation
 */
object TraceCollector {
    private val traces = ConcurrentHashMap<String, TraceData>()
    private var spanCounter = 0

    // Configuration
    var maxTracesInMemory = 100
    var autoGenerateDiagrams = true

    /**
     * Record a span
     */
    fun recordSpan(
        traceId: String,
        spanId: String,
        parentSpanId: String?,
        serviceName: String,
        method: Method,
        uri: String,
        status: Status,
        startTime: Instant,
        duration: Duration
    ) {
        val trace = traces.getOrPut(traceId) { TraceData(traceId) }

        val spanData = SpanData(
            traceId = traceId,
            spanId = spanId,
            parentSpanId = parentSpanId,
            serviceName = serviceName,
            method = method,
            uri = uri,
            status = status,
            startTime = startTime,
            duration = duration,
            order = spanCounter++
        )

        trace.addSpan(spanData)

        // Check if trace is complete (heuristic: wait a bit after last span)
        // In a real system, you'd have explicit trace completion
        scheduleTraceCompletion(traceId)
    }

    private fun scheduleTraceCompletion(traceId: String) {
        Thread {
            Thread.sleep(1000) // Wait 1 second for more spans
            val trace = traces[traceId]
            if (trace != null && !trace.completed) {
                trace.completed = true
                if (autoGenerateDiagrams) {
                    DiagramGenerator.generateDiagram(trace)
                }
            }
        }.start()
    }

    /**
     * Get a trace by ID
     */
    fun getTrace(traceId: String): TraceData? = traces[traceId]

    /**
     * Get all traces
     */
    fun getAllTraces(): List<TraceData> = traces.values.toList()

    /**
     * Clear old traces to prevent memory leaks
     */
    fun cleanup() {
        if (traces.size > maxTracesInMemory) {
            val completedTraces = traces.values.filter { it.completed }
            val toRemove = completedTraces.sortedBy { it.spans.firstOrNull()?.startTime }
                .take(traces.size - maxTracesInMemory)

            toRemove.forEach { traces.remove(it.traceId) }
        }
    }

    /**
     * Clear all traces
     */
    fun clear() {
        traces.clear()
        spanCounter = 0
    }
}
